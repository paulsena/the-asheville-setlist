// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: venues.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getShowBandsForVenue = `-- name: GetShowBandsForVenue :many
SELECT
    sb.show_id,
    b.id,
    b.name,
    b.slug,
    sb.is_headliner
FROM show_bands sb
JOIN bands b ON sb.band_id = b.id
WHERE sb.show_id = ANY($1::int[])
ORDER BY sb.show_id, sb.is_headliner DESC, sb.performance_order DESC NULLS LAST
`

type GetShowBandsForVenueRow struct {
	ShowID      int32  `json:"show_id"`
	ID          int32  `json:"id"`
	Name        string `json:"name"`
	Slug        string `json:"slug"`
	IsHeadliner *bool  `json:"is_headliner"`
}

// Get bands for shows at a venue (batch load for venue detail)
func (q *Queries) GetShowBandsForVenue(ctx context.Context, dollar_1 []int32) ([]GetShowBandsForVenueRow, error) {
	rows, err := q.db.Query(ctx, getShowBandsForVenue, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetShowBandsForVenueRow{}
	for rows.Next() {
		var i GetShowBandsForVenueRow
		if err := rows.Scan(
			&i.ShowID,
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsHeadliner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVenue = `-- name: GetVenue :one

SELECT id, name, slug, address, city, state, zip_code, region, latitude, longitude, capacity, website, phone, image_url, metadata, created_at, updated_at FROM venues
WHERE id = $1 LIMIT 1
`

// ============================================
// VENUES QUERIES
// ============================================
// Get venue by ID
func (q *Queries) GetVenue(ctx context.Context, id int32) (Venue, error) {
	row := q.db.QueryRow(ctx, getVenue, id)
	var i Venue
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Address,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.Region,
		&i.Latitude,
		&i.Longitude,
		&i.Capacity,
		&i.Website,
		&i.Phone,
		&i.ImageUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVenueBySlug = `-- name: GetVenueBySlug :one
SELECT
    id,
    name,
    slug,
    address,
    city,
    state,
    zip_code,
    region,
    latitude,
    longitude,
    capacity,
    website,
    phone,
    image_url,
    metadata,
    created_at,
    updated_at
FROM venues
WHERE slug = $1 LIMIT 1
`

// Get venue by slug for detail page
func (q *Queries) GetVenueBySlug(ctx context.Context, slug string) (Venue, error) {
	row := q.db.QueryRow(ctx, getVenueBySlug, slug)
	var i Venue
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Address,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.Region,
		&i.Latitude,
		&i.Longitude,
		&i.Capacity,
		&i.Website,
		&i.Phone,
		&i.ImageUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVenueUpcomingShows = `-- name: GetVenueUpcomingShows :many
SELECT
    s.id,
    s.title,
    s.date,
    s.price_min,
    s.price_max,
    s.ticket_url,
    s.age_restriction,
    s.status
FROM shows s
WHERE s.venue_id = $1
  AND s.status = 'scheduled'
  AND s.date >= NOW()
ORDER BY s.date ASC
LIMIT $2
`

type GetVenueUpcomingShowsParams struct {
	VenueID int32 `json:"venue_id"`
	Limit   int32 `json:"limit"`
}

type GetVenueUpcomingShowsRow struct {
	ID             int32              `json:"id"`
	Title          *string            `json:"title"`
	Date           pgtype.Timestamptz `json:"date"`
	PriceMin       pgtype.Numeric     `json:"price_min"`
	PriceMax       pgtype.Numeric     `json:"price_max"`
	TicketUrl      *string            `json:"ticket_url"`
	AgeRestriction *string            `json:"age_restriction"`
	Status         *string            `json:"status"`
}

// Get upcoming shows for a venue (for venue detail page)
func (q *Queries) GetVenueUpcomingShows(ctx context.Context, arg GetVenueUpcomingShowsParams) ([]GetVenueUpcomingShowsRow, error) {
	rows, err := q.db.Query(ctx, getVenueUpcomingShows, arg.VenueID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVenueUpcomingShowsRow{}
	for rows.Next() {
		var i GetVenueUpcomingShowsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Date,
			&i.PriceMin,
			&i.PriceMax,
			&i.TicketUrl,
			&i.AgeRestriction,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVenues = `-- name: ListVenues :many
SELECT id, name, slug, address, city, state, zip_code, region, latitude, longitude, capacity, website, phone, image_url, metadata, created_at, updated_at FROM venues
ORDER BY name
`

// List all venues ordered by name
func (q *Queries) ListVenues(ctx context.Context) ([]Venue, error) {
	rows, err := q.db.Query(ctx, listVenues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Venue{}
	for rows.Next() {
		var i Venue
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Address,
			&i.City,
			&i.State,
			&i.ZipCode,
			&i.Region,
			&i.Latitude,
			&i.Longitude,
			&i.Capacity,
			&i.Website,
			&i.Phone,
			&i.ImageUrl,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVenuesByRegion = `-- name: ListVenuesByRegion :many
SELECT
    v.id,
    v.name,
    v.slug,
    v.address,
    v.region,
    v.capacity,
    v.website,
    v.image_url,
    COUNT(s.id) AS upcoming_show_count
FROM venues v
LEFT JOIN shows s ON v.id = s.venue_id
    AND s.status = 'scheduled'
    AND s.date >= NOW()
WHERE v.region = ANY($1::text[])
GROUP BY v.id
ORDER BY v.name
`

type ListVenuesByRegionRow struct {
	ID                int32   `json:"id"`
	Name              string  `json:"name"`
	Slug              string  `json:"slug"`
	Address           *string `json:"address"`
	Region            *string `json:"region"`
	Capacity          *int32  `json:"capacity"`
	Website           *string `json:"website"`
	ImageUrl          *string `json:"image_url"`
	UpcomingShowCount int64   `json:"upcoming_show_count"`
}

// List venues filtered by region(s)
func (q *Queries) ListVenuesByRegion(ctx context.Context, dollar_1 []string) ([]ListVenuesByRegionRow, error) {
	rows, err := q.db.Query(ctx, listVenuesByRegion, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVenuesByRegionRow{}
	for rows.Next() {
		var i ListVenuesByRegionRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Address,
			&i.Region,
			&i.Capacity,
			&i.Website,
			&i.ImageUrl,
			&i.UpcomingShowCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVenuesWithShowCount = `-- name: ListVenuesWithShowCount :many
SELECT
    v.id,
    v.name,
    v.slug,
    v.address,
    v.region,
    v.capacity,
    v.website,
    v.image_url,
    COUNT(s.id) AS upcoming_show_count
FROM venues v
LEFT JOIN shows s ON v.id = s.venue_id
    AND s.status = 'scheduled'
    AND s.date >= NOW()
GROUP BY v.id
ORDER BY v.name
`

type ListVenuesWithShowCountRow struct {
	ID                int32   `json:"id"`
	Name              string  `json:"name"`
	Slug              string  `json:"slug"`
	Address           *string `json:"address"`
	Region            *string `json:"region"`
	Capacity          *int32  `json:"capacity"`
	Website           *string `json:"website"`
	ImageUrl          *string `json:"image_url"`
	UpcomingShowCount int64   `json:"upcoming_show_count"`
}

// List venues with count of upcoming scheduled shows
func (q *Queries) ListVenuesWithShowCount(ctx context.Context) ([]ListVenuesWithShowCountRow, error) {
	rows, err := q.db.Query(ctx, listVenuesWithShowCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVenuesWithShowCountRow{}
	for rows.Next() {
		var i ListVenuesWithShowCountRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Address,
			&i.Region,
			&i.Capacity,
			&i.Website,
			&i.ImageUrl,
			&i.UpcomingShowCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchVenues = `-- name: SearchVenues :many
SELECT
    id,
    name,
    slug
FROM venues
WHERE to_tsvector('english', name) @@ plainto_tsquery('english', $1)
ORDER BY name
LIMIT $2
`

type SearchVenuesParams struct {
	PlaintoTsquery string `json:"plainto_tsquery"`
	Limit          int32  `json:"limit"`
}

type SearchVenuesRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
	Slug string `json:"slug"`
}

// Full-text search on venue names
func (q *Queries) SearchVenues(ctx context.Context, arg SearchVenuesParams) ([]SearchVenuesRow, error) {
	rows, err := q.db.Query(ctx, searchVenues, arg.PlaintoTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchVenuesRow{}
	for rows.Next() {
		var i SearchVenuesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Slug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const venueExists = `-- name: VenueExists :one
SELECT EXISTS(SELECT 1 FROM venues WHERE id = $1)
`

// Check if venue exists by ID (for validation)
func (q *Queries) VenueExists(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, venueExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
