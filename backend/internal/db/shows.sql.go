// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: shows.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countShowsByGenre = `-- name: CountShowsByGenre :one
SELECT COUNT(DISTINCT s.id)
FROM shows s
JOIN show_bands sb ON s.id = sb.show_id
JOIN band_genres bg ON sb.band_id = bg.band_id
JOIN genres g ON bg.genre_id = g.id
WHERE s.date >= NOW()
  AND s.status = 'scheduled'
  AND g.slug = ANY($1::text[])
`

// Count upcoming shows by genre (for genre filter)
func (q *Queries) CountShowsByGenre(ctx context.Context, dollar_1 []string) (int64, error) {
	row := q.db.QueryRow(ctx, countShowsByGenre, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createShow = `-- name: CreateShow :one
INSERT INTO shows (
    venue_id,
    title,
    image_url,
    date,
    doors_time,
    show_time,
    price_min,
    price_max,
    ticket_url,
    age_restriction,
    status,
    source
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, status, created_at
`

type CreateShowParams struct {
	VenueID        int32              `json:"venue_id"`
	Title          *string            `json:"title"`
	ImageUrl       *string            `json:"image_url"`
	Date           pgtype.Timestamptz `json:"date"`
	DoorsTime      pgtype.Time        `json:"doors_time"`
	ShowTime       pgtype.Time        `json:"show_time"`
	PriceMin       pgtype.Numeric     `json:"price_min"`
	PriceMax       pgtype.Numeric     `json:"price_max"`
	TicketUrl      *string            `json:"ticket_url"`
	AgeRestriction *string            `json:"age_restriction"`
	Status         *string            `json:"status"`
	Source         *string            `json:"source"`
}

type CreateShowRow struct {
	ID        int32              `json:"id"`
	Status    *string            `json:"status"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Create a new show (band submission)
func (q *Queries) CreateShow(ctx context.Context, arg CreateShowParams) (CreateShowRow, error) {
	row := q.db.QueryRow(ctx, createShow,
		arg.VenueID,
		arg.Title,
		arg.ImageUrl,
		arg.Date,
		arg.DoorsTime,
		arg.ShowTime,
		arg.PriceMin,
		arg.PriceMax,
		arg.TicketUrl,
		arg.AgeRestriction,
		arg.Status,
		arg.Source,
	)
	var i CreateShowRow
	err := row.Scan(&i.ID, &i.Status, &i.CreatedAt)
	return i, err
}

const createShowBand = `-- name: CreateShowBand :exec
INSERT INTO show_bands (show_id, band_id, is_headliner, performance_order)
VALUES ($1, $2, $3, $4)
`

type CreateShowBandParams struct {
	ShowID           int32  `json:"show_id"`
	BandID           int32  `json:"band_id"`
	IsHeadliner      *bool  `json:"is_headliner"`
	PerformanceOrder *int32 `json:"performance_order"`
}

// Link a band to a show
func (q *Queries) CreateShowBand(ctx context.Context, arg CreateShowBandParams) error {
	_, err := q.db.Exec(ctx, createShowBand,
		arg.ShowID,
		arg.BandID,
		arg.IsHeadliner,
		arg.PerformanceOrder,
	)
	return err
}

const getBandGenresForShow = `-- name: GetBandGenresForShow :many
SELECT
    g.id,
    g.name,
    g.slug
FROM genres g
JOIN band_genres bg ON g.id = bg.genre_id
WHERE bg.band_id = $1
ORDER BY g.name
`

type GetBandGenresForShowRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
	Slug string `json:"slug"`
}

// Get genres for a band (used when fetching show details)
func (q *Queries) GetBandGenresForShow(ctx context.Context, bandID int32) ([]GetBandGenresForShowRow, error) {
	rows, err := q.db.Query(ctx, getBandGenresForShow, bandID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBandGenresForShowRow{}
	for rows.Next() {
		var i GetBandGenresForShowRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Slug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShowBands = `-- name: GetShowBands :many
SELECT
    b.id,
    b.name,
    b.slug,
    b.bio,
    b.image_url,
    b.spotify_url,
    b.website,
    sb.is_headliner,
    sb.performance_order
FROM bands b
JOIN show_bands sb ON b.id = sb.band_id
WHERE sb.show_id = $1
ORDER BY sb.performance_order DESC NULLS LAST, sb.is_headliner DESC
`

type GetShowBandsRow struct {
	ID               int32   `json:"id"`
	Name             string  `json:"name"`
	Slug             string  `json:"slug"`
	Bio              *string `json:"bio"`
	ImageUrl         *string `json:"image_url"`
	SpotifyUrl       *string `json:"spotify_url"`
	Website          *string `json:"website"`
	IsHeadliner      *bool   `json:"is_headliner"`
	PerformanceOrder *int32  `json:"performance_order"`
}

// Get all bands for a show with their genres
func (q *Queries) GetShowBands(ctx context.Context, showID int32) ([]GetShowBandsRow, error) {
	rows, err := q.db.Query(ctx, getShowBands, showID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetShowBandsRow{}
	for rows.Next() {
		var i GetShowBandsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Bio,
			&i.ImageUrl,
			&i.SpotifyUrl,
			&i.Website,
			&i.IsHeadliner,
			&i.PerformanceOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShowByID = `-- name: GetShowByID :one

SELECT
    s.id,
    s.title,
    s.description,
    s.image_url,
    s.date,
    s.doors_time,
    s.show_time,
    s.price_min,
    s.price_max,
    s.ticket_url,
    s.age_restriction,
    s.status,
    s.source,
    s.created_at,
    s.updated_at,
    v.id AS venue_id,
    v.name AS venue_name,
    v.slug AS venue_slug,
    v.address AS venue_address,
    v.region AS venue_region,
    v.website AS venue_website,
    v.image_url AS venue_image_url
FROM shows s
JOIN venues v ON s.venue_id = v.id
WHERE s.id = $1
`

type GetShowByIDRow struct {
	ID             int32              `json:"id"`
	Title          *string            `json:"title"`
	Description    *string            `json:"description"`
	ImageUrl       *string            `json:"image_url"`
	Date           pgtype.Timestamptz `json:"date"`
	DoorsTime      pgtype.Time        `json:"doors_time"`
	ShowTime       pgtype.Time        `json:"show_time"`
	PriceMin       pgtype.Numeric     `json:"price_min"`
	PriceMax       pgtype.Numeric     `json:"price_max"`
	TicketUrl      *string            `json:"ticket_url"`
	AgeRestriction *string            `json:"age_restriction"`
	Status         *string            `json:"status"`
	Source         *string            `json:"source"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	VenueID        int32              `json:"venue_id"`
	VenueName      string             `json:"venue_name"`
	VenueSlug      string             `json:"venue_slug"`
	VenueAddress   *string            `json:"venue_address"`
	VenueRegion    *string            `json:"venue_region"`
	VenueWebsite   *string            `json:"venue_website"`
	VenueImageUrl  *string            `json:"venue_image_url"`
}

// ============================================
// SHOWS QUERIES
// ============================================
// Get single show with venue info
func (q *Queries) GetShowByID(ctx context.Context, id int32) (GetShowByIDRow, error) {
	row := q.db.QueryRow(ctx, getShowByID, id)
	var i GetShowByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ImageUrl,
		&i.Date,
		&i.DoorsTime,
		&i.ShowTime,
		&i.PriceMin,
		&i.PriceMax,
		&i.TicketUrl,
		&i.AgeRestriction,
		&i.Status,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.VenueID,
		&i.VenueName,
		&i.VenueSlug,
		&i.VenueAddress,
		&i.VenueRegion,
		&i.VenueWebsite,
		&i.VenueImageUrl,
	)
	return i, err
}

const listFreeShows = `-- name: ListFreeShows :many
SELECT
    s.id,
    s.title,
    s.image_url,
    s.date,
    s.doors_time,
    s.show_time,
    s.price_min,
    s.price_max,
    s.ticket_url,
    s.age_restriction,
    s.status,
    v.id AS venue_id,
    v.name AS venue_name,
    v.slug AS venue_slug,
    v.region AS venue_region,
    v.address AS venue_address,
    v.image_url AS venue_image_url,
    COUNT(*) OVER() AS total_count
FROM shows s
JOIN venues v ON s.venue_id = v.id
WHERE s.date >= NOW()
  AND s.status = 'scheduled'
  AND (s.price_min IS NULL OR s.price_min = 0)
ORDER BY s.date ASC, s.id ASC
LIMIT $1 OFFSET $2
`

type ListFreeShowsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListFreeShowsRow struct {
	ID             int32              `json:"id"`
	Title          *string            `json:"title"`
	ImageUrl       *string            `json:"image_url"`
	Date           pgtype.Timestamptz `json:"date"`
	DoorsTime      pgtype.Time        `json:"doors_time"`
	ShowTime       pgtype.Time        `json:"show_time"`
	PriceMin       pgtype.Numeric     `json:"price_min"`
	PriceMax       pgtype.Numeric     `json:"price_max"`
	TicketUrl      *string            `json:"ticket_url"`
	AgeRestriction *string            `json:"age_restriction"`
	Status         *string            `json:"status"`
	VenueID        int32              `json:"venue_id"`
	VenueName      string             `json:"venue_name"`
	VenueSlug      string             `json:"venue_slug"`
	VenueRegion    *string            `json:"venue_region"`
	VenueAddress   *string            `json:"venue_address"`
	VenueImageUrl  *string            `json:"venue_image_url"`
	TotalCount     int64              `json:"total_count"`
}

// Shows that are free (price_min is NULL or 0)
func (q *Queries) ListFreeShows(ctx context.Context, arg ListFreeShowsParams) ([]ListFreeShowsRow, error) {
	rows, err := q.db.Query(ctx, listFreeShows, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFreeShowsRow{}
	for rows.Next() {
		var i ListFreeShowsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ImageUrl,
			&i.Date,
			&i.DoorsTime,
			&i.ShowTime,
			&i.PriceMin,
			&i.PriceMax,
			&i.TicketUrl,
			&i.AgeRestriction,
			&i.Status,
			&i.VenueID,
			&i.VenueName,
			&i.VenueSlug,
			&i.VenueRegion,
			&i.VenueAddress,
			&i.VenueImageUrl,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShowsByDateRange = `-- name: ListShowsByDateRange :many
SELECT
    s.id,
    s.title,
    s.image_url,
    s.date,
    s.doors_time,
    s.show_time,
    s.price_min,
    s.price_max,
    s.ticket_url,
    s.age_restriction,
    s.status,
    v.id AS venue_id,
    v.name AS venue_name,
    v.slug AS venue_slug,
    v.region AS venue_region,
    v.address AS venue_address,
    v.image_url AS venue_image_url,
    COUNT(*) OVER() AS total_count
FROM shows s
JOIN venues v ON s.venue_id = v.id
WHERE s.date >= $1
  AND s.date <= $2
  AND s.status = 'scheduled'
ORDER BY s.date ASC, s.id ASC
LIMIT $3 OFFSET $4
`

type ListShowsByDateRangeParams struct {
	Date   pgtype.Timestamptz `json:"date"`
	Date_2 pgtype.Timestamptz `json:"date_2"`
	Limit  int32              `json:"limit"`
	Offset int32              `json:"offset"`
}

type ListShowsByDateRangeRow struct {
	ID             int32              `json:"id"`
	Title          *string            `json:"title"`
	ImageUrl       *string            `json:"image_url"`
	Date           pgtype.Timestamptz `json:"date"`
	DoorsTime      pgtype.Time        `json:"doors_time"`
	ShowTime       pgtype.Time        `json:"show_time"`
	PriceMin       pgtype.Numeric     `json:"price_min"`
	PriceMax       pgtype.Numeric     `json:"price_max"`
	TicketUrl      *string            `json:"ticket_url"`
	AgeRestriction *string            `json:"age_restriction"`
	Status         *string            `json:"status"`
	VenueID        int32              `json:"venue_id"`
	VenueName      string             `json:"venue_name"`
	VenueSlug      string             `json:"venue_slug"`
	VenueRegion    *string            `json:"venue_region"`
	VenueAddress   *string            `json:"venue_address"`
	VenueImageUrl  *string            `json:"venue_image_url"`
	TotalCount     int64              `json:"total_count"`
}

// Filter shows by date range (inclusive)
func (q *Queries) ListShowsByDateRange(ctx context.Context, arg ListShowsByDateRangeParams) ([]ListShowsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, listShowsByDateRange,
		arg.Date,
		arg.Date_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListShowsByDateRangeRow{}
	for rows.Next() {
		var i ListShowsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ImageUrl,
			&i.Date,
			&i.DoorsTime,
			&i.ShowTime,
			&i.PriceMin,
			&i.PriceMax,
			&i.TicketUrl,
			&i.AgeRestriction,
			&i.Status,
			&i.VenueID,
			&i.VenueName,
			&i.VenueSlug,
			&i.VenueRegion,
			&i.VenueAddress,
			&i.VenueImageUrl,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShowsByGenre = `-- name: ListShowsByGenre :many
SELECT DISTINCT ON (s.date, s.id)
    s.id,
    s.title,
    s.image_url,
    s.date,
    s.doors_time,
    s.show_time,
    s.price_min,
    s.price_max,
    s.ticket_url,
    s.age_restriction,
    s.status,
    v.id AS venue_id,
    v.name AS venue_name,
    v.slug AS venue_slug,
    v.region AS venue_region,
    v.address AS venue_address,
    v.image_url AS venue_image_url
FROM shows s
JOIN venues v ON s.venue_id = v.id
JOIN show_bands sb ON s.id = sb.show_id
JOIN band_genres bg ON sb.band_id = bg.band_id
JOIN genres g ON bg.genre_id = g.id
WHERE s.date >= NOW()
  AND s.status = 'scheduled'
  AND g.slug = ANY($1::text[])
ORDER BY s.date ASC, s.id ASC
LIMIT $2 OFFSET $3
`

type ListShowsByGenreParams struct {
	Column1 []string `json:"column_1"`
	Limit   int32    `json:"limit"`
	Offset  int32    `json:"offset"`
}

type ListShowsByGenreRow struct {
	ID             int32              `json:"id"`
	Title          *string            `json:"title"`
	ImageUrl       *string            `json:"image_url"`
	Date           pgtype.Timestamptz `json:"date"`
	DoorsTime      pgtype.Time        `json:"doors_time"`
	ShowTime       pgtype.Time        `json:"show_time"`
	PriceMin       pgtype.Numeric     `json:"price_min"`
	PriceMax       pgtype.Numeric     `json:"price_max"`
	TicketUrl      *string            `json:"ticket_url"`
	AgeRestriction *string            `json:"age_restriction"`
	Status         *string            `json:"status"`
	VenueID        int32              `json:"venue_id"`
	VenueName      string             `json:"venue_name"`
	VenueSlug      string             `json:"venue_slug"`
	VenueRegion    *string            `json:"venue_region"`
	VenueAddress   *string            `json:"venue_address"`
	VenueImageUrl  *string            `json:"venue_image_url"`
}

// Filter shows by genre slug(s) - shows with bands matching any of the genres
func (q *Queries) ListShowsByGenre(ctx context.Context, arg ListShowsByGenreParams) ([]ListShowsByGenreRow, error) {
	rows, err := q.db.Query(ctx, listShowsByGenre, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListShowsByGenreRow{}
	for rows.Next() {
		var i ListShowsByGenreRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ImageUrl,
			&i.Date,
			&i.DoorsTime,
			&i.ShowTime,
			&i.PriceMin,
			&i.PriceMax,
			&i.TicketUrl,
			&i.AgeRestriction,
			&i.Status,
			&i.VenueID,
			&i.VenueName,
			&i.VenueSlug,
			&i.VenueRegion,
			&i.VenueAddress,
			&i.VenueImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShowsByPriceRange = `-- name: ListShowsByPriceRange :many
SELECT
    s.id,
    s.title,
    s.image_url,
    s.date,
    s.doors_time,
    s.show_time,
    s.price_min,
    s.price_max,
    s.ticket_url,
    s.age_restriction,
    s.status,
    v.id AS venue_id,
    v.name AS venue_name,
    v.slug AS venue_slug,
    v.region AS venue_region,
    v.address AS venue_address,
    v.image_url AS venue_image_url,
    COUNT(*) OVER() AS total_count
FROM shows s
JOIN venues v ON s.venue_id = v.id
WHERE s.date >= NOW()
  AND s.status = 'scheduled'
  AND (s.price_min IS NULL OR s.price_min >= $1)
  AND (s.price_max IS NULL OR s.price_max <= $2)
ORDER BY s.date ASC, s.id ASC
LIMIT $3 OFFSET $4
`

type ListShowsByPriceRangeParams struct {
	PriceMin pgtype.Numeric `json:"price_min"`
	PriceMax pgtype.Numeric `json:"price_max"`
	Limit    int32          `json:"limit"`
	Offset   int32          `json:"offset"`
}

type ListShowsByPriceRangeRow struct {
	ID             int32              `json:"id"`
	Title          *string            `json:"title"`
	ImageUrl       *string            `json:"image_url"`
	Date           pgtype.Timestamptz `json:"date"`
	DoorsTime      pgtype.Time        `json:"doors_time"`
	ShowTime       pgtype.Time        `json:"show_time"`
	PriceMin       pgtype.Numeric     `json:"price_min"`
	PriceMax       pgtype.Numeric     `json:"price_max"`
	TicketUrl      *string            `json:"ticket_url"`
	AgeRestriction *string            `json:"age_restriction"`
	Status         *string            `json:"status"`
	VenueID        int32              `json:"venue_id"`
	VenueName      string             `json:"venue_name"`
	VenueSlug      string             `json:"venue_slug"`
	VenueRegion    *string            `json:"venue_region"`
	VenueAddress   *string            `json:"venue_address"`
	VenueImageUrl  *string            `json:"venue_image_url"`
	TotalCount     int64              `json:"total_count"`
}

// Filter shows by price range
func (q *Queries) ListShowsByPriceRange(ctx context.Context, arg ListShowsByPriceRangeParams) ([]ListShowsByPriceRangeRow, error) {
	rows, err := q.db.Query(ctx, listShowsByPriceRange,
		arg.PriceMin,
		arg.PriceMax,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListShowsByPriceRangeRow{}
	for rows.Next() {
		var i ListShowsByPriceRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ImageUrl,
			&i.Date,
			&i.DoorsTime,
			&i.ShowTime,
			&i.PriceMin,
			&i.PriceMax,
			&i.TicketUrl,
			&i.AgeRestriction,
			&i.Status,
			&i.VenueID,
			&i.VenueName,
			&i.VenueSlug,
			&i.VenueRegion,
			&i.VenueAddress,
			&i.VenueImageUrl,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShowsByRegion = `-- name: ListShowsByRegion :many
SELECT
    s.id,
    s.title,
    s.image_url,
    s.date,
    s.doors_time,
    s.show_time,
    s.price_min,
    s.price_max,
    s.ticket_url,
    s.age_restriction,
    s.status,
    v.id AS venue_id,
    v.name AS venue_name,
    v.slug AS venue_slug,
    v.region AS venue_region,
    v.address AS venue_address,
    v.image_url AS venue_image_url,
    COUNT(*) OVER() AS total_count
FROM shows s
JOIN venues v ON s.venue_id = v.id
WHERE s.date >= NOW()
  AND s.status = 'scheduled'
  AND v.region = ANY($1::text[])
ORDER BY s.date ASC, s.id ASC
LIMIT $2 OFFSET $3
`

type ListShowsByRegionParams struct {
	Column1 []string `json:"column_1"`
	Limit   int32    `json:"limit"`
	Offset  int32    `json:"offset"`
}

type ListShowsByRegionRow struct {
	ID             int32              `json:"id"`
	Title          *string            `json:"title"`
	ImageUrl       *string            `json:"image_url"`
	Date           pgtype.Timestamptz `json:"date"`
	DoorsTime      pgtype.Time        `json:"doors_time"`
	ShowTime       pgtype.Time        `json:"show_time"`
	PriceMin       pgtype.Numeric     `json:"price_min"`
	PriceMax       pgtype.Numeric     `json:"price_max"`
	TicketUrl      *string            `json:"ticket_url"`
	AgeRestriction *string            `json:"age_restriction"`
	Status         *string            `json:"status"`
	VenueID        int32              `json:"venue_id"`
	VenueName      string             `json:"venue_name"`
	VenueSlug      string             `json:"venue_slug"`
	VenueRegion    *string            `json:"venue_region"`
	VenueAddress   *string            `json:"venue_address"`
	VenueImageUrl  *string            `json:"venue_image_url"`
	TotalCount     int64              `json:"total_count"`
}

// Filter shows by region(s)
func (q *Queries) ListShowsByRegion(ctx context.Context, arg ListShowsByRegionParams) ([]ListShowsByRegionRow, error) {
	rows, err := q.db.Query(ctx, listShowsByRegion, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListShowsByRegionRow{}
	for rows.Next() {
		var i ListShowsByRegionRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ImageUrl,
			&i.Date,
			&i.DoorsTime,
			&i.ShowTime,
			&i.PriceMin,
			&i.PriceMax,
			&i.TicketUrl,
			&i.AgeRestriction,
			&i.Status,
			&i.VenueID,
			&i.VenueName,
			&i.VenueSlug,
			&i.VenueRegion,
			&i.VenueAddress,
			&i.VenueImageUrl,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShowsByVenue = `-- name: ListShowsByVenue :many
SELECT
    s.id,
    s.title,
    s.image_url,
    s.date,
    s.doors_time,
    s.show_time,
    s.price_min,
    s.price_max,
    s.ticket_url,
    s.age_restriction,
    s.status,
    v.id AS venue_id,
    v.name AS venue_name,
    v.slug AS venue_slug,
    v.region AS venue_region,
    v.address AS venue_address,
    v.image_url AS venue_image_url,
    COUNT(*) OVER() AS total_count
FROM shows s
JOIN venues v ON s.venue_id = v.id
WHERE s.date >= NOW()
  AND s.status = 'scheduled'
  AND v.slug = ANY($1::text[])
ORDER BY s.date ASC, s.id ASC
LIMIT $2 OFFSET $3
`

type ListShowsByVenueParams struct {
	Column1 []string `json:"column_1"`
	Limit   int32    `json:"limit"`
	Offset  int32    `json:"offset"`
}

type ListShowsByVenueRow struct {
	ID             int32              `json:"id"`
	Title          *string            `json:"title"`
	ImageUrl       *string            `json:"image_url"`
	Date           pgtype.Timestamptz `json:"date"`
	DoorsTime      pgtype.Time        `json:"doors_time"`
	ShowTime       pgtype.Time        `json:"show_time"`
	PriceMin       pgtype.Numeric     `json:"price_min"`
	PriceMax       pgtype.Numeric     `json:"price_max"`
	TicketUrl      *string            `json:"ticket_url"`
	AgeRestriction *string            `json:"age_restriction"`
	Status         *string            `json:"status"`
	VenueID        int32              `json:"venue_id"`
	VenueName      string             `json:"venue_name"`
	VenueSlug      string             `json:"venue_slug"`
	VenueRegion    *string            `json:"venue_region"`
	VenueAddress   *string            `json:"venue_address"`
	VenueImageUrl  *string            `json:"venue_image_url"`
	TotalCount     int64              `json:"total_count"`
}

// Filter shows by venue slug(s)
func (q *Queries) ListShowsByVenue(ctx context.Context, arg ListShowsByVenueParams) ([]ListShowsByVenueRow, error) {
	rows, err := q.db.Query(ctx, listShowsByVenue, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListShowsByVenueRow{}
	for rows.Next() {
		var i ListShowsByVenueRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ImageUrl,
			&i.Date,
			&i.DoorsTime,
			&i.ShowTime,
			&i.PriceMin,
			&i.PriceMax,
			&i.TicketUrl,
			&i.AgeRestriction,
			&i.Status,
			&i.VenueID,
			&i.VenueName,
			&i.VenueSlug,
			&i.VenueRegion,
			&i.VenueAddress,
			&i.VenueImageUrl,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShowsThisWeekend = `-- name: ListShowsThisWeekend :many
SELECT
    s.id,
    s.title,
    s.image_url,
    s.date,
    s.doors_time,
    s.show_time,
    s.price_min,
    s.price_max,
    s.ticket_url,
    s.age_restriction,
    s.status,
    v.id AS venue_id,
    v.name AS venue_name,
    v.slug AS venue_slug,
    v.region AS venue_region,
    v.address AS venue_address,
    v.image_url AS venue_image_url
FROM shows s
JOIN venues v ON s.venue_id = v.id
WHERE s.date >= DATE_TRUNC('week', NOW()) + INTERVAL '4 days'  -- Friday
  AND s.date < DATE_TRUNC('week', NOW()) + INTERVAL '8 days'   -- Monday
  AND s.status = 'scheduled'
ORDER BY s.date ASC, s.id ASC
`

type ListShowsThisWeekendRow struct {
	ID             int32              `json:"id"`
	Title          *string            `json:"title"`
	ImageUrl       *string            `json:"image_url"`
	Date           pgtype.Timestamptz `json:"date"`
	DoorsTime      pgtype.Time        `json:"doors_time"`
	ShowTime       pgtype.Time        `json:"show_time"`
	PriceMin       pgtype.Numeric     `json:"price_min"`
	PriceMax       pgtype.Numeric     `json:"price_max"`
	TicketUrl      *string            `json:"ticket_url"`
	AgeRestriction *string            `json:"age_restriction"`
	Status         *string            `json:"status"`
	VenueID        int32              `json:"venue_id"`
	VenueName      string             `json:"venue_name"`
	VenueSlug      string             `json:"venue_slug"`
	VenueRegion    *string            `json:"venue_region"`
	VenueAddress   *string            `json:"venue_address"`
	VenueImageUrl  *string            `json:"venue_image_url"`
}

// Shows happening Friday-Sunday of current or next weekend
func (q *Queries) ListShowsThisWeekend(ctx context.Context) ([]ListShowsThisWeekendRow, error) {
	rows, err := q.db.Query(ctx, listShowsThisWeekend)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListShowsThisWeekendRow{}
	for rows.Next() {
		var i ListShowsThisWeekendRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ImageUrl,
			&i.Date,
			&i.DoorsTime,
			&i.ShowTime,
			&i.PriceMin,
			&i.PriceMax,
			&i.TicketUrl,
			&i.AgeRestriction,
			&i.Status,
			&i.VenueID,
			&i.VenueName,
			&i.VenueSlug,
			&i.VenueRegion,
			&i.VenueAddress,
			&i.VenueImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShowsTonight = `-- name: ListShowsTonight :many
SELECT
    s.id,
    s.title,
    s.image_url,
    s.date,
    s.doors_time,
    s.show_time,
    s.price_min,
    s.price_max,
    s.ticket_url,
    s.age_restriction,
    s.status,
    v.id AS venue_id,
    v.name AS venue_name,
    v.slug AS venue_slug,
    v.region AS venue_region,
    v.address AS venue_address,
    v.image_url AS venue_image_url
FROM shows s
JOIN venues v ON s.venue_id = v.id
WHERE DATE(s.date AT TIME ZONE 'America/New_York') = DATE(NOW() AT TIME ZONE 'America/New_York')
  AND s.status = 'scheduled'
ORDER BY s.date ASC, s.id ASC
`

type ListShowsTonightRow struct {
	ID             int32              `json:"id"`
	Title          *string            `json:"title"`
	ImageUrl       *string            `json:"image_url"`
	Date           pgtype.Timestamptz `json:"date"`
	DoorsTime      pgtype.Time        `json:"doors_time"`
	ShowTime       pgtype.Time        `json:"show_time"`
	PriceMin       pgtype.Numeric     `json:"price_min"`
	PriceMax       pgtype.Numeric     `json:"price_max"`
	TicketUrl      *string            `json:"ticket_url"`
	AgeRestriction *string            `json:"age_restriction"`
	Status         *string            `json:"status"`
	VenueID        int32              `json:"venue_id"`
	VenueName      string             `json:"venue_name"`
	VenueSlug      string             `json:"venue_slug"`
	VenueRegion    *string            `json:"venue_region"`
	VenueAddress   *string            `json:"venue_address"`
	VenueImageUrl  *string            `json:"venue_image_url"`
}

// Shows happening today
func (q *Queries) ListShowsTonight(ctx context.Context) ([]ListShowsTonightRow, error) {
	rows, err := q.db.Query(ctx, listShowsTonight)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListShowsTonightRow{}
	for rows.Next() {
		var i ListShowsTonightRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ImageUrl,
			&i.Date,
			&i.DoorsTime,
			&i.ShowTime,
			&i.PriceMin,
			&i.PriceMax,
			&i.TicketUrl,
			&i.AgeRestriction,
			&i.Status,
			&i.VenueID,
			&i.VenueName,
			&i.VenueSlug,
			&i.VenueRegion,
			&i.VenueAddress,
			&i.VenueImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingShows = `-- name: ListUpcomingShows :many
SELECT
    s.id,
    s.title,
    s.image_url,
    s.date,
    s.doors_time,
    s.show_time,
    s.price_min,
    s.price_max,
    s.ticket_url,
    s.age_restriction,
    s.status,
    v.id AS venue_id,
    v.name AS venue_name,
    v.slug AS venue_slug,
    v.region AS venue_region,
    v.address AS venue_address,
    v.image_url AS venue_image_url,
    COUNT(*) OVER() AS total_count
FROM shows s
JOIN venues v ON s.venue_id = v.id
WHERE s.date >= NOW()
  AND s.status = 'scheduled'
ORDER BY s.date ASC, s.id ASC
LIMIT $1 OFFSET $2
`

type ListUpcomingShowsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListUpcomingShowsRow struct {
	ID             int32              `json:"id"`
	Title          *string            `json:"title"`
	ImageUrl       *string            `json:"image_url"`
	Date           pgtype.Timestamptz `json:"date"`
	DoorsTime      pgtype.Time        `json:"doors_time"`
	ShowTime       pgtype.Time        `json:"show_time"`
	PriceMin       pgtype.Numeric     `json:"price_min"`
	PriceMax       pgtype.Numeric     `json:"price_max"`
	TicketUrl      *string            `json:"ticket_url"`
	AgeRestriction *string            `json:"age_restriction"`
	Status         *string            `json:"status"`
	VenueID        int32              `json:"venue_id"`
	VenueName      string             `json:"venue_name"`
	VenueSlug      string             `json:"venue_slug"`
	VenueRegion    *string            `json:"venue_region"`
	VenueAddress   *string            `json:"venue_address"`
	VenueImageUrl  *string            `json:"venue_image_url"`
	TotalCount     int64              `json:"total_count"`
}

// List upcoming scheduled shows with pagination
// Used for homepage and general show listing
func (q *Queries) ListUpcomingShows(ctx context.Context, arg ListUpcomingShowsParams) ([]ListUpcomingShowsRow, error) {
	rows, err := q.db.Query(ctx, listUpcomingShows, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUpcomingShowsRow{}
	for rows.Next() {
		var i ListUpcomingShowsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ImageUrl,
			&i.Date,
			&i.DoorsTime,
			&i.ShowTime,
			&i.PriceMin,
			&i.PriceMax,
			&i.TicketUrl,
			&i.AgeRestriction,
			&i.Status,
			&i.VenueID,
			&i.VenueName,
			&i.VenueSlug,
			&i.VenueRegion,
			&i.VenueAddress,
			&i.VenueImageUrl,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchShows = `-- name: SearchShows :many
SELECT
    s.id,
    s.title,
    s.date,
    v.name AS venue_name
FROM shows s
JOIN venues v ON s.venue_id = v.id
WHERE s.date >= NOW()
  AND s.status = 'scheduled'
  AND to_tsvector('english', COALESCE(s.title, '')) @@ plainto_tsquery('english', $1)
ORDER BY s.date ASC
LIMIT $2
`

type SearchShowsParams struct {
	PlaintoTsquery string `json:"plainto_tsquery"`
	Limit          int32  `json:"limit"`
}

type SearchShowsRow struct {
	ID        int32              `json:"id"`
	Title     *string            `json:"title"`
	Date      pgtype.Timestamptz `json:"date"`
	VenueName string             `json:"venue_name"`
}

// Full-text search on show titles
func (q *Queries) SearchShows(ctx context.Context, arg SearchShowsParams) ([]SearchShowsRow, error) {
	rows, err := q.db.Query(ctx, searchShows, arg.PlaintoTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchShowsRow{}
	for rows.Next() {
		var i SearchShowsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Date,
			&i.VenueName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
