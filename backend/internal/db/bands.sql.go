// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bands.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBandGenre = `-- name: AddBandGenre :exec
INSERT INTO band_genres (band_id, genre_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddBandGenreParams struct {
	BandID  int32 `json:"band_id"`
	GenreID int32 `json:"genre_id"`
}

// Add a genre to a band
func (q *Queries) AddBandGenre(ctx context.Context, arg AddBandGenreParams) error {
	_, err := q.db.Exec(ctx, addBandGenre, arg.BandID, arg.GenreID)
	return err
}

const bandExists = `-- name: BandExists :one
SELECT EXISTS(SELECT 1 FROM bands WHERE slug = $1)
`

// Check if band exists by slug
func (q *Queries) BandExists(ctx context.Context, slug string) (bool, error) {
	row := q.db.QueryRow(ctx, bandExists, slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countBandsByGenre = `-- name: CountBandsByGenre :one
SELECT COUNT(DISTINCT b.id)
FROM bands b
JOIN band_genres bg ON b.id = bg.band_id
JOIN genres g ON bg.genre_id = g.id
WHERE g.slug = ANY($1::text[])
`

// Count bands by genre (for pagination)
func (q *Queries) CountBandsByGenre(ctx context.Context, dollar_1 []string) (int64, error) {
	row := q.db.QueryRow(ctx, countBandsByGenre, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBand = `-- name: CreateBand :one
INSERT INTO bands (name, slug)
VALUES ($1, $2)
RETURNING id, name, slug, created_at
`

type CreateBandParams struct {
	Name string `json:"name"`
	Slug string `json:"slug"`
}

type CreateBandRow struct {
	ID        int32              `json:"id"`
	Name      string             `json:"name"`
	Slug      string             `json:"slug"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Create a new band
func (q *Queries) CreateBand(ctx context.Context, arg CreateBandParams) (CreateBandRow, error) {
	row := q.db.QueryRow(ctx, createBand, arg.Name, arg.Slug)
	var i CreateBandRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
	)
	return i, err
}

const createBandFull = `-- name: CreateBandFull :one
INSERT INTO bands (
    name,
    slug,
    bio,
    hometown,
    image_url,
    website,
    spotify_url,
    instagram,
    facebook,
    bandcamp_url
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, name, slug, bio, hometown, image_url, website, spotify_url, instagram, facebook, bandcamp_url, metadata, created_at, updated_at
`

type CreateBandFullParams struct {
	Name        string  `json:"name"`
	Slug        string  `json:"slug"`
	Bio         *string `json:"bio"`
	Hometown    *string `json:"hometown"`
	ImageUrl    *string `json:"image_url"`
	Website     *string `json:"website"`
	SpotifyUrl  *string `json:"spotify_url"`
	Instagram   *string `json:"instagram"`
	Facebook    *string `json:"facebook"`
	BandcampUrl *string `json:"bandcamp_url"`
}

// Create a new band with all fields
func (q *Queries) CreateBandFull(ctx context.Context, arg CreateBandFullParams) (Band, error) {
	row := q.db.QueryRow(ctx, createBandFull,
		arg.Name,
		arg.Slug,
		arg.Bio,
		arg.Hometown,
		arg.ImageUrl,
		arg.Website,
		arg.SpotifyUrl,
		arg.Instagram,
		arg.Facebook,
		arg.BandcampUrl,
	)
	var i Band
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Bio,
		&i.Hometown,
		&i.ImageUrl,
		&i.Website,
		&i.SpotifyUrl,
		&i.Instagram,
		&i.Facebook,
		&i.BandcampUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBand = `-- name: GetBand :one

SELECT id, name, slug, bio, hometown, image_url, website, spotify_url, instagram, facebook, bandcamp_url, metadata, created_at, updated_at FROM bands
WHERE id = $1 LIMIT 1
`

// ============================================
// BANDS QUERIES
// ============================================
// Get band by ID
func (q *Queries) GetBand(ctx context.Context, id int32) (Band, error) {
	row := q.db.QueryRow(ctx, getBand, id)
	var i Band
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Bio,
		&i.Hometown,
		&i.ImageUrl,
		&i.Website,
		&i.SpotifyUrl,
		&i.Instagram,
		&i.Facebook,
		&i.BandcampUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBandByName = `-- name: GetBandByName :one
SELECT id, name, slug, bio, hometown, image_url, website, spotify_url, instagram, facebook, bandcamp_url, metadata, created_at, updated_at FROM bands
WHERE LOWER(name) = LOWER($1) LIMIT 1
`

// Get band by name (case-insensitive) for matching during submissions
func (q *Queries) GetBandByName(ctx context.Context, lower string) (Band, error) {
	row := q.db.QueryRow(ctx, getBandByName, lower)
	var i Band
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Bio,
		&i.Hometown,
		&i.ImageUrl,
		&i.Website,
		&i.SpotifyUrl,
		&i.Instagram,
		&i.Facebook,
		&i.BandcampUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBandBySlug = `-- name: GetBandBySlug :one
SELECT
    id,
    name,
    slug,
    bio,
    hometown,
    image_url,
    website,
    spotify_url,
    instagram,
    facebook,
    bandcamp_url,
    metadata,
    created_at,
    updated_at
FROM bands
WHERE slug = $1 LIMIT 1
`

// Get band by slug for detail page
func (q *Queries) GetBandBySlug(ctx context.Context, slug string) (Band, error) {
	row := q.db.QueryRow(ctx, getBandBySlug, slug)
	var i Band
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Bio,
		&i.Hometown,
		&i.ImageUrl,
		&i.Website,
		&i.SpotifyUrl,
		&i.Instagram,
		&i.Facebook,
		&i.BandcampUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBandGenres = `-- name: GetBandGenres :many
SELECT
    g.id,
    g.name,
    g.slug
FROM genres g
JOIN band_genres bg ON g.id = bg.genre_id
WHERE bg.band_id = $1
ORDER BY g.name
`

type GetBandGenresRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
	Slug string `json:"slug"`
}

// Get genres for a band
func (q *Queries) GetBandGenres(ctx context.Context, bandID int32) ([]GetBandGenresRow, error) {
	rows, err := q.db.Query(ctx, getBandGenres, bandID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBandGenresRow{}
	for rows.Next() {
		var i GetBandGenresRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Slug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBandGenresBatch = `-- name: GetBandGenresBatch :many
SELECT
    bg.band_id,
    g.id,
    g.name,
    g.slug
FROM genres g
JOIN band_genres bg ON g.id = bg.genre_id
WHERE bg.band_id = ANY($1::int[])
ORDER BY bg.band_id, g.name
`

type GetBandGenresBatchRow struct {
	BandID int32  `json:"band_id"`
	ID     int32  `json:"id"`
	Name   string `json:"name"`
	Slug   string `json:"slug"`
}

// Get genres for multiple bands (batch load)
func (q *Queries) GetBandGenresBatch(ctx context.Context, dollar_1 []int32) ([]GetBandGenresBatchRow, error) {
	rows, err := q.db.Query(ctx, getBandGenresBatch, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBandGenresBatchRow{}
	for rows.Next() {
		var i GetBandGenresBatchRow
		if err := rows.Scan(
			&i.BandID,
			&i.ID,
			&i.Name,
			&i.Slug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBandUpcomingShows = `-- name: GetBandUpcomingShows :many
SELECT
    s.id,
    s.date,
    s.title,
    v.id AS venue_id,
    v.name AS venue_name,
    v.slug AS venue_slug,
    sb.is_headliner
FROM shows s
JOIN show_bands sb ON s.id = sb.show_id
JOIN venues v ON s.venue_id = v.id
WHERE sb.band_id = $1
  AND s.status = 'scheduled'
  AND s.date >= NOW()
ORDER BY s.date ASC
`

type GetBandUpcomingShowsRow struct {
	ID          int32              `json:"id"`
	Date        pgtype.Timestamptz `json:"date"`
	Title       *string            `json:"title"`
	VenueID     int32              `json:"venue_id"`
	VenueName   string             `json:"venue_name"`
	VenueSlug   string             `json:"venue_slug"`
	IsHeadliner *bool              `json:"is_headliner"`
}

// Get upcoming shows for a band
func (q *Queries) GetBandUpcomingShows(ctx context.Context, bandID int32) ([]GetBandUpcomingShowsRow, error) {
	rows, err := q.db.Query(ctx, getBandUpcomingShows, bandID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBandUpcomingShowsRow{}
	for rows.Next() {
		var i GetBandUpcomingShowsRow
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Title,
			&i.VenueID,
			&i.VenueName,
			&i.VenueSlug,
			&i.IsHeadliner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarBands = `-- name: GetSimilarBands :many
SELECT
    b.id,
    b.name,
    b.slug,
    b.image_url,
    COUNT(bg1.genre_id) AS shared_genre_count
FROM bands b
JOIN band_genres bg1 ON b.id = bg1.band_id
JOIN band_genres bg2 ON bg1.genre_id = bg2.genre_id
WHERE bg2.band_id = $1
  AND b.id != $1
GROUP BY b.id, b.name, b.slug, b.image_url
ORDER BY shared_genre_count DESC, b.name ASC
LIMIT $2
`

type GetSimilarBandsParams struct {
	BandID int32 `json:"band_id"`
	Limit  int32 `json:"limit"`
}

type GetSimilarBandsRow struct {
	ID               int32   `json:"id"`
	Name             string  `json:"name"`
	Slug             string  `json:"slug"`
	ImageUrl         *string `json:"image_url"`
	SharedGenreCount int64   `json:"shared_genre_count"`
}

// Find bands with shared genres (similar bands)
// Excludes the source band and orders by number of shared genres
func (q *Queries) GetSimilarBands(ctx context.Context, arg GetSimilarBandsParams) ([]GetSimilarBandsRow, error) {
	rows, err := q.db.Query(ctx, getSimilarBands, arg.BandID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSimilarBandsRow{}
	for rows.Next() {
		var i GetSimilarBandsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.ImageUrl,
			&i.SharedGenreCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarBandsWithGenres = `-- name: GetSimilarBandsWithGenres :many
SELECT
    b.id,
    b.name,
    b.slug,
    b.image_url,
    COUNT(bg1.genre_id) AS shared_genre_count,
    ARRAY_AGG(g.name ORDER BY g.name) AS shared_genres,
    ARRAY_AGG(g.id ORDER BY g.name) AS shared_genre_ids,
    ARRAY_AGG(g.slug ORDER BY g.name) AS shared_genre_slugs
FROM bands b
JOIN band_genres bg1 ON b.id = bg1.band_id
JOIN band_genres bg2 ON bg1.genre_id = bg2.genre_id
JOIN genres g ON bg1.genre_id = g.id
WHERE bg2.band_id = $1
  AND b.id != $1
GROUP BY b.id, b.name, b.slug, b.image_url
ORDER BY shared_genre_count DESC, b.name ASC
LIMIT $2
`

type GetSimilarBandsWithGenresParams struct {
	BandID int32 `json:"band_id"`
	Limit  int32 `json:"limit"`
}

type GetSimilarBandsWithGenresRow struct {
	ID               int32       `json:"id"`
	Name             string      `json:"name"`
	Slug             string      `json:"slug"`
	ImageUrl         *string     `json:"image_url"`
	SharedGenreCount int64       `json:"shared_genre_count"`
	SharedGenres     interface{} `json:"shared_genres"`
	SharedGenreIds   interface{} `json:"shared_genre_ids"`
	SharedGenreSlugs interface{} `json:"shared_genre_slugs"`
}

// Find similar bands with their shared genre names
func (q *Queries) GetSimilarBandsWithGenres(ctx context.Context, arg GetSimilarBandsWithGenresParams) ([]GetSimilarBandsWithGenresRow, error) {
	rows, err := q.db.Query(ctx, getSimilarBandsWithGenres, arg.BandID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSimilarBandsWithGenresRow{}
	for rows.Next() {
		var i GetSimilarBandsWithGenresRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.ImageUrl,
			&i.SharedGenreCount,
			&i.SharedGenres,
			&i.SharedGenreIds,
			&i.SharedGenreSlugs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBands = `-- name: ListBands :many
SELECT
    b.id,
    b.name,
    b.slug,
    b.bio,
    b.hometown,
    b.image_url,
    COUNT(*) OVER() AS total_count
FROM bands b
ORDER BY b.name
LIMIT $1 OFFSET $2
`

type ListBandsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListBandsRow struct {
	ID         int32   `json:"id"`
	Name       string  `json:"name"`
	Slug       string  `json:"slug"`
	Bio        *string `json:"bio"`
	Hometown   *string `json:"hometown"`
	ImageUrl   *string `json:"image_url"`
	TotalCount int64   `json:"total_count"`
}

// List bands with pagination
func (q *Queries) ListBands(ctx context.Context, arg ListBandsParams) ([]ListBandsRow, error) {
	rows, err := q.db.Query(ctx, listBands, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBandsRow{}
	for rows.Next() {
		var i ListBandsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Bio,
			&i.Hometown,
			&i.ImageUrl,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBandsByGenre = `-- name: ListBandsByGenre :many
SELECT DISTINCT ON (b.name, b.id)
    b.id,
    b.name,
    b.slug,
    b.bio,
    b.hometown,
    b.image_url
FROM bands b
JOIN band_genres bg ON b.id = bg.band_id
JOIN genres g ON bg.genre_id = g.id
WHERE g.slug = ANY($1::text[])
ORDER BY b.name, b.id
LIMIT $2 OFFSET $3
`

type ListBandsByGenreParams struct {
	Column1 []string `json:"column_1"`
	Limit   int32    `json:"limit"`
	Offset  int32    `json:"offset"`
}

type ListBandsByGenreRow struct {
	ID       int32   `json:"id"`
	Name     string  `json:"name"`
	Slug     string  `json:"slug"`
	Bio      *string `json:"bio"`
	Hometown *string `json:"hometown"`
	ImageUrl *string `json:"image_url"`
}

// List bands filtered by genre slug(s) with pagination
func (q *Queries) ListBandsByGenre(ctx context.Context, arg ListBandsByGenreParams) ([]ListBandsByGenreRow, error) {
	rows, err := q.db.Query(ctx, listBandsByGenre, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBandsByGenreRow{}
	for rows.Next() {
		var i ListBandsByGenreRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Bio,
			&i.Hometown,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBands = `-- name: SearchBands :many
SELECT
    id,
    name,
    slug,
    bio,
    hometown,
    image_url,
    COUNT(*) OVER() AS total_count
FROM bands
WHERE to_tsvector('english', name || ' ' || COALESCE(bio, '')) @@ plainto_tsquery('english', $1)
ORDER BY name
LIMIT $2 OFFSET $3
`

type SearchBandsParams struct {
	PlaintoTsquery string `json:"plainto_tsquery"`
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
}

type SearchBandsRow struct {
	ID         int32   `json:"id"`
	Name       string  `json:"name"`
	Slug       string  `json:"slug"`
	Bio        *string `json:"bio"`
	Hometown   *string `json:"hometown"`
	ImageUrl   *string `json:"image_url"`
	TotalCount int64   `json:"total_count"`
}

// Full-text search on band name and bio
func (q *Queries) SearchBands(ctx context.Context, arg SearchBandsParams) ([]SearchBandsRow, error) {
	rows, err := q.db.Query(ctx, searchBands, arg.PlaintoTsquery, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchBandsRow{}
	for rows.Next() {
		var i SearchBandsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Bio,
			&i.Hometown,
			&i.ImageUrl,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBandsSimple = `-- name: SearchBandsSimple :many
SELECT
    id,
    name,
    slug
FROM bands
WHERE to_tsvector('english', name || ' ' || COALESCE(bio, '')) @@ plainto_tsquery('english', $1)
ORDER BY name
LIMIT $2
`

type SearchBandsSimpleParams struct {
	PlaintoTsquery string `json:"plainto_tsquery"`
	Limit          int32  `json:"limit"`
}

type SearchBandsSimpleRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
	Slug string `json:"slug"`
}

// Simple search returning minimal fields (for global search)
func (q *Queries) SearchBandsSimple(ctx context.Context, arg SearchBandsSimpleParams) ([]SearchBandsSimpleRow, error) {
	rows, err := q.db.Query(ctx, searchBandsSimple, arg.PlaintoTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchBandsSimpleRow{}
	for rows.Next() {
		var i SearchBandsSimpleRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Slug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
