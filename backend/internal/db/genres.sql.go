// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: genres.sql

package db

import (
	"context"
)

const countBandsInGenre = `-- name: CountBandsInGenre :one
SELECT COUNT(*)
FROM band_genres
WHERE genre_id = $1
`

// Count bands in a genre (for pagination)
func (q *Queries) CountBandsInGenre(ctx context.Context, genreID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countBandsInGenre, genreID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const genreExists = `-- name: GenreExists :one
SELECT EXISTS(SELECT 1 FROM genres WHERE id = $1)
`

// Check if genre exists by ID
func (q *Queries) GenreExists(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, genreExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const genreExistsBySlug = `-- name: GenreExistsBySlug :one
SELECT EXISTS(SELECT 1 FROM genres WHERE slug = $1)
`

// Check if genre exists by slug
func (q *Queries) GenreExistsBySlug(ctx context.Context, slug string) (bool, error) {
	row := q.db.QueryRow(ctx, genreExistsBySlug, slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getBandsByGenre = `-- name: GetBandsByGenre :many
SELECT
    b.id,
    b.name,
    b.slug,
    b.image_url,
    b.hometown
FROM bands b
JOIN band_genres bg ON b.id = bg.band_id
WHERE bg.genre_id = $1
ORDER BY b.name
LIMIT $2 OFFSET $3
`

type GetBandsByGenreParams struct {
	GenreID int32 `json:"genre_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

type GetBandsByGenreRow struct {
	ID       int32   `json:"id"`
	Name     string  `json:"name"`
	Slug     string  `json:"slug"`
	ImageUrl *string `json:"image_url"`
	Hometown *string `json:"hometown"`
}

// Get bands for a specific genre (for genre detail page)
func (q *Queries) GetBandsByGenre(ctx context.Context, arg GetBandsByGenreParams) ([]GetBandsByGenreRow, error) {
	rows, err := q.db.Query(ctx, getBandsByGenre, arg.GenreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBandsByGenreRow{}
	for rows.Next() {
		var i GetBandsByGenreRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.ImageUrl,
			&i.Hometown,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGenre = `-- name: GetGenre :one

SELECT id, name, slug, description, created_at FROM genres
WHERE id = $1 LIMIT 1
`

// ============================================
// GENRES QUERIES
// ============================================
// Get genre by ID
func (q *Queries) GetGenre(ctx context.Context, id int32) (Genre, error) {
	row := q.db.QueryRow(ctx, getGenre, id)
	var i Genre
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getGenreBySlug = `-- name: GetGenreBySlug :one
SELECT
    id,
    name,
    slug,
    description,
    created_at
FROM genres
WHERE slug = $1 LIMIT 1
`

// Get genre by slug
func (q *Queries) GetGenreBySlug(ctx context.Context, slug string) (Genre, error) {
	row := q.db.QueryRow(ctx, getGenreBySlug, slug)
	var i Genre
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const listGenres = `-- name: ListGenres :many
SELECT
    id,
    name,
    slug,
    description,
    created_at
FROM genres
ORDER BY name
`

// List all genres ordered by name
func (q *Queries) ListGenres(ctx context.Context) ([]Genre, error) {
	rows, err := q.db.Query(ctx, listGenres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Genre{}
	for rows.Next() {
		var i Genre
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGenresWithBandCount = `-- name: ListGenresWithBandCount :many
SELECT
    g.id,
    g.name,
    g.slug,
    g.description,
    COUNT(bg.band_id) AS band_count
FROM genres g
LEFT JOIN band_genres bg ON g.id = bg.genre_id
GROUP BY g.id
ORDER BY g.name
`

type ListGenresWithBandCountRow struct {
	ID          int32   `json:"id"`
	Name        string  `json:"name"`
	Slug        string  `json:"slug"`
	Description *string `json:"description"`
	BandCount   int64   `json:"band_count"`
}

// List genres with count of bands
func (q *Queries) ListGenresWithBandCount(ctx context.Context) ([]ListGenresWithBandCountRow, error) {
	rows, err := q.db.Query(ctx, listGenresWithBandCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGenresWithBandCountRow{}
	for rows.Next() {
		var i ListGenresWithBandCountRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.BandCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGenresWithShowCount = `-- name: ListGenresWithShowCount :many
SELECT
    g.id,
    g.name,
    g.slug,
    g.description,
    COUNT(DISTINCT s.id) AS show_count
FROM genres g
LEFT JOIN band_genres bg ON g.id = bg.genre_id
LEFT JOIN show_bands sb ON bg.band_id = sb.band_id
LEFT JOIN shows s ON sb.show_id = s.id
    AND s.status = 'scheduled'
    AND s.date >= NOW()
GROUP BY g.id
ORDER BY g.name
`

type ListGenresWithShowCountRow struct {
	ID          int32   `json:"id"`
	Name        string  `json:"name"`
	Slug        string  `json:"slug"`
	Description *string `json:"description"`
	ShowCount   int64   `json:"show_count"`
}

// List genres with count of upcoming shows
func (q *Queries) ListGenresWithShowCount(ctx context.Context) ([]ListGenresWithShowCountRow, error) {
	rows, err := q.db.Query(ctx, listGenresWithShowCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGenresWithShowCountRow{}
	for rows.Next() {
		var i ListGenresWithShowCountRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ShowCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
