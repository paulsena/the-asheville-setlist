// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: search.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const globalSearchBands = `-- name: GlobalSearchBands :many
SELECT
    id,
    name,
    slug
FROM bands
WHERE to_tsvector('english', name || ' ' || COALESCE(bio, '')) @@ plainto_tsquery('english', $1)
ORDER BY name ASC
LIMIT $2
`

type GlobalSearchBandsParams struct {
	PlaintoTsquery string `json:"plainto_tsquery"`
	Limit          int32  `json:"limit"`
}

type GlobalSearchBandsRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
	Slug string `json:"slug"`
}

// Search bands only (for search endpoint's bands section)
func (q *Queries) GlobalSearchBands(ctx context.Context, arg GlobalSearchBandsParams) ([]GlobalSearchBandsRow, error) {
	rows, err := q.db.Query(ctx, globalSearchBands, arg.PlaintoTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GlobalSearchBandsRow{}
	for rows.Next() {
		var i GlobalSearchBandsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Slug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const globalSearchShows = `-- name: GlobalSearchShows :many
SELECT
    s.id,
    s.title,
    s.date,
    v.name AS venue_name
FROM shows s
JOIN venues v ON s.venue_id = v.id
WHERE s.date >= NOW()
  AND s.status = 'scheduled'
  AND to_tsvector('english', COALESCE(s.title, '')) @@ plainto_tsquery('english', $1)
ORDER BY s.date ASC
LIMIT $2
`

type GlobalSearchShowsParams struct {
	PlaintoTsquery string `json:"plainto_tsquery"`
	Limit          int32  `json:"limit"`
}

type GlobalSearchShowsRow struct {
	ID        int32              `json:"id"`
	Title     *string            `json:"title"`
	Date      pgtype.Timestamptz `json:"date"`
	VenueName string             `json:"venue_name"`
}

// Search shows only (for search endpoint's shows section)
func (q *Queries) GlobalSearchShows(ctx context.Context, arg GlobalSearchShowsParams) ([]GlobalSearchShowsRow, error) {
	rows, err := q.db.Query(ctx, globalSearchShows, arg.PlaintoTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GlobalSearchShowsRow{}
	for rows.Next() {
		var i GlobalSearchShowsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Date,
			&i.VenueName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const globalSearchVenues = `-- name: GlobalSearchVenues :many
SELECT
    id,
    name,
    slug
FROM venues
WHERE to_tsvector('english', name) @@ plainto_tsquery('english', $1)
ORDER BY name ASC
LIMIT $2
`

type GlobalSearchVenuesParams struct {
	PlaintoTsquery string `json:"plainto_tsquery"`
	Limit          int32  `json:"limit"`
}

type GlobalSearchVenuesRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
	Slug string `json:"slug"`
}

// Search venues only (for search endpoint's venues section)
func (q *Queries) GlobalSearchVenues(ctx context.Context, arg GlobalSearchVenuesParams) ([]GlobalSearchVenuesRow, error) {
	rows, err := q.db.Query(ctx, globalSearchVenues, arg.PlaintoTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GlobalSearchVenuesRow{}
	for rows.Next() {
		var i GlobalSearchVenuesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Slug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAll = `-- name: SearchAll :many

SELECT
    'show' AS entity_type,
    s.id,
    COALESCE(s.title, '') AS name,
    v.name AS extra_info,
    s.date::text AS date_info
FROM shows s
JOIN venues v ON s.venue_id = v.id
WHERE s.date >= NOW()
  AND s.status = 'scheduled'
  AND to_tsvector('english', COALESCE(s.title, '')) @@ plainto_tsquery('english', $1)

UNION ALL

SELECT
    'band' AS entity_type,
    b.id,
    b.name,
    b.slug AS extra_info,
    NULL AS date_info
FROM bands b
WHERE to_tsvector('english', b.name || ' ' || COALESCE(b.bio, '')) @@ plainto_tsquery('english', $1)

UNION ALL

SELECT
    'venue' AS entity_type,
    v.id,
    v.name,
    v.slug AS extra_info,
    NULL AS date_info
FROM venues v
WHERE to_tsvector('english', v.name) @@ plainto_tsquery('english', $1)

LIMIT $2
`

type SearchAllParams struct {
	PlaintoTsquery string `json:"plainto_tsquery"`
	Limit          int32  `json:"limit"`
}

type SearchAllRow struct {
	EntityType string `json:"entity_type"`
	ID         int32  `json:"id"`
	Name       string `json:"name"`
	ExtraInfo  string `json:"extra_info"`
	DateInfo   string `json:"date_info"`
}

// ============================================
// GLOBAL SEARCH QUERIES
// ============================================
// Unified search across shows, bands, and venues
// Returns results with a type discriminator
// Note: This uses UNION ALL for efficiency (no deduplication needed)
func (q *Queries) SearchAll(ctx context.Context, arg SearchAllParams) ([]SearchAllRow, error) {
	rows, err := q.db.Query(ctx, searchAll, arg.PlaintoTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchAllRow{}
	for rows.Next() {
		var i SearchAllRow
		if err := rows.Scan(
			&i.EntityType,
			&i.ID,
			&i.Name,
			&i.ExtraInfo,
			&i.DateInfo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchShowsWithBands = `-- name: SearchShowsWithBands :many
SELECT DISTINCT ON (s.date, s.id)
    s.id,
    s.title,
    s.date,
    v.name AS venue_name
FROM shows s
JOIN venues v ON s.venue_id = v.id
LEFT JOIN show_bands sb ON s.id = sb.show_id
LEFT JOIN bands b ON sb.band_id = b.id
WHERE s.date >= NOW()
  AND s.status = 'scheduled'
  AND (
    to_tsvector('english', COALESCE(s.title, '')) @@ plainto_tsquery('english', $1)
    OR to_tsvector('english', COALESCE(b.name, '')) @@ plainto_tsquery('english', $1)
  )
ORDER BY s.date ASC, s.id ASC
LIMIT $2
`

type SearchShowsWithBandsParams struct {
	PlaintoTsquery string `json:"plainto_tsquery"`
	Limit          int32  `json:"limit"`
}

type SearchShowsWithBandsRow struct {
	ID        int32              `json:"id"`
	Title     *string            `json:"title"`
	Date      pgtype.Timestamptz `json:"date"`
	VenueName string             `json:"venue_name"`
}

// Search shows including band names in the search
// This finds shows where either the title OR any band name matches
func (q *Queries) SearchShowsWithBands(ctx context.Context, arg SearchShowsWithBandsParams) ([]SearchShowsWithBandsRow, error) {
	rows, err := q.db.Query(ctx, searchShowsWithBands, arg.PlaintoTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchShowsWithBandsRow{}
	for rows.Next() {
		var i SearchShowsWithBandsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Date,
			&i.VenueName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
